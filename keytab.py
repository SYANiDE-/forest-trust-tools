from struct import unpack, pack
from impacket.structure import Structure
import binascii
import sys

# Keytab structure from http://www.ioplex.com/utilities/keytab.txt
# keytab {
#     uint16_t file_format_version;                    /* 0x502 */
#     keytab_entry entries[*];
# };

# keytab_entry {
#     int32_t size;
#     uint16_t num_components;    /* sub 1 if version 0x501 */
#     counted_octet_string realm;
#     counted_octet_string components[num_components];
#     uint32_t name_type;   /* not present if version 0x501 */
#     uint32_t timestamp;
#     uint8_t vno8;
#     keyblock key;
#     uint32_t vno; /* only present if >= 4 bytes left in entry */
# };

# counted_octet_string {
#     uint16_t length;
#     uint8_t data[length];
# };

# keyblock {
#     uint16_t type;
#     counted_octet_string;
# };


class KeyTab(Structure):
    structure = (("file_format_version", "H=517"), ("keytab_entry", ":"))

    def fromString(self, data):
        self.entries = []
        Structure.fromString(self, data)
        data = self["keytab_entry"]
        while len(data) != 0:
            ktentry = KeyTabEntry(data)

            data = data[len(ktentry.getData()) :]
            self.entries.append(ktentry)

    def getData(self):
        self["keytab_entry"] = b"".join([entry.getData() for entry in self.entries])
        data = Structure.getData(self)
        return data


class OctetString(Structure):
    structure = (("len", ">H-value"), ("value", ":"))


class KeyTabContentRest(Structure):
    structure = (
        ("name_type", ">I=1"),
        ("timestamp", ">I=0"),
        ("vno8", "B=2"),
        ("keytype", ">H"),
        ("keylen", ">H-key"),
        ("key", ":"),
    )


class KeyTabContent(Structure):
    structure = (
        ("num_components", ">h"),
        ("realmlen", ">h-realm"),
        ("realm", ":"),
        ("components", ":"),
        ("restdata", ":"),
    )

    def fromString(self, data):
        self.components = []
        Structure.fromString(self, data)
        data = self["components"]
        for i in range(self["num_components"]):
            ktentry = OctetString(data)

            data = data[ktentry["len"] + 2 :]
            self.components.append(ktentry)
        self.restfields = KeyTabContentRest(data)

    def getData(self):
        self["num_components"] = len(self.components)
        # We modify the data field to be able to use the
        # parent class parsing
        self["components"] = b"".join(
            [component.getData() for component in self.components]
        )
        self["restdata"] = self.restfields.getData()
        data = Structure.getData(self)
        return data


class KeyTabEntry(Structure):
    structure = (("size", ">I-content"), ("content", ":", KeyTabContent))


# Add your own keys here!
# Keys are tuples in the form (keytype, 'hexencodedkey')
# Common keytypes for Windows:
# 23: RC4
# 18: AES-256
# 17: AES-128
# Wireshark takes any number of keys in the keytab, so feel free to add
# krbtgt keys, service keys, trust keys etc
keys = [
    (23, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
    (18, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
    (17, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
    (18, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
    (23, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
]

nkt = KeyTab()
nkt.entries = []

for key in keys:
    ktcr = KeyTabContentRest()
    ktcr["keytype"] = key[0]
    ktcr["key"] = binascii.unhexlify(key[1])
    nktcontent = KeyTabContent()
    nktcontent.restfields = ktcr
    # The realm here doesn't matter for wireshark but does of course for a real keytab
    nktcontent["realm"] = b"TESTSEGMENT.LOCAL"
    krbtgt = OctetString()
    krbtgt["value"] = "krbtgt"
    nktcontent.components = [krbtgt]
    nktentry = KeyTabEntry()
    nktentry["content"] = nktcontent
    nkt.entries.append(nktentry)

data = nkt.getData()
if len(sys.argv) < 2:
    print("Usage: keytab.py <outputfile>")
    print("Keys should be written to the source manually")
else:
    with open(sys.argv[1], "wb") as outfile:
        outfile.write(data)
